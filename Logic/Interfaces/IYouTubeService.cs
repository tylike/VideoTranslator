using System;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Threading;
using VideoTranslator.Config;
using VideoTranslator.Models;
using VideoTranslator.Services;
using YoutubeExplode;
using YoutubeExplode.Videos.Streams;

namespace VideoTranslator.Interfaces;

public interface IYouTubeService
{
    Task<YouTubeVideo> GetVideoInfoAsync(string url);
    Task<string> DownloadVideoAsync(string url, string outputPath,  CancellationToken cancellationToken = default);
    Task<string> DownloadVideoAsync(string url, string videoQualityUrl, string audioQualityUrl, string outputPath,  CancellationToken cancellationToken = default);
    Task<string> DownloadVideoAsync(string url, YouTubeVideoStream? videoStream, YouTubeAudio? audioStream, string outputPath, CancellationToken cancellationToken = default);
    Task<string> DownloadAudioAsync(string url, string outputPath, CancellationToken cancellationToken = default);
    Task<string> DownloadSubtitleAsync(string url, string languageCode, string outputPath);
    Task<List<YouTubeSubtitle>> GetAvailableSubtitlesAsync(string url);
    Task<List<YouTubeAudio>> GetAvailableAudiosAsync(string url);
}
public class YouTubeService : ServiceBase, IYouTubeService
{
    private readonly YoutubeClient _youtubeClient;
    
    private readonly TimeSpan _defaultTimeout = TimeSpan.FromMinutes(30);    

    public YouTubeService() : base()
    {
        _youtubeClient = new YoutubeClient();
    }

    public async Task<YouTubeVideo> GetVideoInfoAsync(string url)
    {
        var overallStopwatch = Stopwatch.StartNew();
        progress?.Report($"[YouTubeService] ============================================");
        progress?.Report($"[YouTubeService] 开始获取视频信息...");
        progress?.Report($"[YouTubeService] URL: {url}");

        #region 获取基本信息
        progress?.ReportProgress(10, "正在获取基本信息...");
        var stepStopwatch = Stopwatch.StartNew();
        var videoId = ExtractVideoId(url);
        var video = await _youtubeClient.Videos.GetAsync(url);
        stepStopwatch.Stop();
        progress?.Report($"[YouTubeService] ✓ 获取基本信息耗时: {stepStopwatch.ElapsedMilliseconds}ms");
        #endregion

        var result = new YouTubeVideo
        {
            VideoId = videoId,
            Title = video.Title,
            Url = url,
            ThumbnailUrl = video.Thumbnails.FirstOrDefault()?.Url,
            Duration = video.Duration ?? TimeSpan.Zero
        };

        #region 获取字幕列表
        progress?.ReportProgress(30, "正在获取字幕列表...");
        stepStopwatch.Restart();
        try
        {
            var trackManifest = await _youtubeClient.Videos.ClosedCaptions.GetManifestAsync(url);
            foreach (var trackInfo in trackManifest.Tracks)
            {
                result.AvailableSubtitles.Add(new YouTubeSubtitle
                {
                    LanguageCode = trackInfo.Language.Code,
                    LanguageName = trackInfo.Language.Name,
                    IsAutoGenerated = trackInfo.IsAutoGenerated
                });
            }
            stepStopwatch.Stop();
            progress?.Report($"[YouTubeService] ✓ 获取字幕列表耗时: {stepStopwatch.ElapsedMilliseconds}ms (共 {result.AvailableSubtitles.Count} 条字幕)");
        }
        catch (Exception ex)
        {
            stepStopwatch.Stop();
            progress?.Error($"[YouTubeService] ✗ 获取字幕列表失败 (耗时: {stepStopwatch.ElapsedMilliseconds}ms): {ex.Message}");
        }
        #endregion

        #region 获取流清单（音频和视频）
        progress?.ReportProgress(50, "正在获取流清单...");
        stepStopwatch.Restart();
        StreamManifest? streamManifest = null;
        try
        {
            streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(url, verifyContentLength: false);
            stepStopwatch.Stop();
            progress?.Report($"[YouTubeService] ✓ 获取流清单耗时: {stepStopwatch.ElapsedMilliseconds}ms");
        }
        catch (Exception ex)
        {
            stepStopwatch.Stop();
            progress?.Error($"[YouTubeService] ✗ 获取流清单失败 (耗时: {stepStopwatch.ElapsedMilliseconds}ms): {ex.Message}");
        }
        #endregion

        #region 性能对比：获取视频流
        if (streamManifest != null)
        {
            progress?.Report($"[YouTubeService] ============================================");
            progress?.Report($"[YouTubeService] 性能对比测试：获取视频流");
            progress?.Report($"[YouTubeService] ============================================");

            #region 方法1：使用 TryGetWithHighestVideoQuality
            stepStopwatch.Restart();
            try
            {
                var videoStreamInfos = streamManifest.GetVideoOnlyStreams().ToList();
                var highestQualityStream = videoStreamInfos.TryGetWithHighestVideoQuality();
                stepStopwatch.Stop();
                progress?.Report($"[YouTubeService] ✓ 方法1 - TryGetWithHighestVideoQuality 耗时: {stepStopwatch.ElapsedMilliseconds}ms");
                if (highestQualityStream != null)
                {
                    progress?.Report($"[YouTubeService]   最高质量: {highestQualityStream.VideoQuality.Label} - {highestQualityStream.VideoResolution}");
                }
            }
            catch (Exception ex)
            {
                stepStopwatch.Stop();
                progress?.Error($"[YouTubeService] ✗ 方法1失败 (耗时: {stepStopwatch.ElapsedMilliseconds}ms): {ex.Message}");
            }
            #endregion

            #region 方法2：手动遍历比较
            stepStopwatch.Restart();
            try
            {
                var videoStreamInfos = streamManifest.GetVideoOnlyStreams().ToList();
                IVideoStreamInfo? highestQualityStream = null;
                foreach (var stream in videoStreamInfos)
                {
                    if (highestQualityStream == null || stream.VideoQuality > highestQualityStream.VideoQuality)
                    {
                        highestQualityStream = stream;
                    }
                }
                stepStopwatch.Stop();
                progress?.Report($"[YouTubeService] ✓ 方法2 - 手动遍历比较 耗时: {stepStopwatch.ElapsedMilliseconds}ms");
                if (highestQualityStream != null)
                {
                    progress?.Report($"[YouTubeService]   最高质量: {highestQualityStream.VideoQuality.Label} - {highestQualityStream.VideoResolution}");
                }
            }
            catch (Exception ex)
            {
                stepStopwatch.Stop();
                progress?.Error($"[YouTubeService] ✗ 方法2失败 (耗时: {stepStopwatch.ElapsedMilliseconds}ms): {ex.Message}");
            }
            #endregion

            progress?.Report($"[YouTubeService] ============================================");
            progress?.Report($"[YouTubeService] 性能对比测试完成");
            progress?.Report($"[YouTubeService] ============================================");
        }
        #endregion

        #region 获取音频流信息
        progress?.ReportProgress(70, "正在获取音频流信息...");
        if (streamManifest != null)
        {
            stepStopwatch.Restart();
            try
            {
                var audioStreamInfos = streamManifest.GetAudioOnlyStreams().ToList();
                foreach (var stream in audioStreamInfos)
                {
                    result.AvailableAudios.Add(new YouTubeAudio
                    {
                        FormatId = stream.Url,
                        Extension = stream.Container.Name,
                        Quality = stream.Bitrate.ToString(),
                        Bitrate = (int)(stream.Bitrate.BitsPerSecond / 1000),
                        FileSize = stream.Size.Bytes
                    });
                }
                stepStopwatch.Stop();
                progress?.Report($"[YouTubeService] ✓ 处理音频流耗时: {stepStopwatch.ElapsedMilliseconds}ms (共 {result.AvailableAudios.Count} 个音频流)");
            }
            catch (Exception ex)
            {
                stepStopwatch.Stop();
                progress?.Error($"[YouTubeService] ✗ 获取音频格式列表失败 (耗时: {stepStopwatch.ElapsedMilliseconds}ms): {ex.Message}");
            }
        }
        #endregion

        #region 获取视频流信息
        progress?.ReportProgress(90, "正在获取视频流信息...");
        if (streamManifest != null)
        {
            stepStopwatch.Restart();
            try
            {
                var videoStreamInfos = streamManifest.GetVideoOnlyStreams().ToList();
                foreach (var stream in videoStreamInfos)
                {
                    result.AvailableVideos.Add(new YouTubeVideoStream
                    {
                        FormatId = stream.Url,
                        Extension = stream.Container.Name,
                        Resolution = $"{stream.VideoResolution.Width}x{stream.VideoResolution.Height}",
                        QualityLabel = stream.VideoQuality.Label,
                        Framerate = stream.VideoQuality.Framerate,
                        FileSize = stream.Size.Bytes,
                        DownloadUrl = stream.Url
                    });
                }
                stepStopwatch.Stop();
                progress?.Report($"[YouTubeService] ✓ 处理视频流耗时: {stepStopwatch.ElapsedMilliseconds}ms (共 {result.AvailableVideos.Count} 个视频流)");
            }
            catch (Exception ex)
            {
                stepStopwatch.Stop();
                progress?.Error($"[YouTubeService] ✗ 获取视频格式列表失败 (耗时: {stepStopwatch.ElapsedMilliseconds}ms): {ex.Message}");
            }
        }
        #endregion

        progress?.ReportProgress(100, "获取视频信息完成");
        overallStopwatch.Stop();
        progress?.Report($"[YouTubeService] ============================================");
        progress?.Report($"[YouTubeService] 总耗时: {overallStopwatch.ElapsedMilliseconds}ms ({overallStopwatch.Elapsed.TotalSeconds:F2}秒)");
        progress?.Report($"[YouTubeService] ============================================");

        return result;
    }

    public async Task<string> DownloadVideoAsync(string url, string outputPath, CancellationToken cancellationToken = default)
    {
        progress?.Report($"[YouTubeService] ============================================");
        progress?.Report($"[YouTubeService] 开始下载视频...");
        progress?.Report($"[YouTubeService] URL: {url}");
        progress?.Report($"[YouTubeService] 输出路径: {outputPath}");

        var video = await _youtubeClient.Videos.GetAsync(url);
        var title = string.Join("", video.Title.Split(Path.GetInvalidFileNameChars()));
        var outputDir = Path.GetDirectoryName(outputPath) ?? ".";
        var tempVideoPath = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}_video.mp4");
        var tempAudioPath = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}_audio.m4a");
        var tempMergedPath = $"{tempVideoPath}_merged.mp4";

        progress?.Report($"[YouTubeService] 临时视频路径: {tempVideoPath}");
        progress?.Report($"[YouTubeService] 临时音频路径: {tempAudioPath}");
        progress?.Report($"[YouTubeService] 临时合并路径: {tempMergedPath}");

        var startTime = DateTime.Now;

        try
        {
            var streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(url, verifyContentLength: false);

            var muxedStreams = streamManifest.GetMuxedStreams().ToList();
            progress?.Report($"[YouTubeService] 可用混合流数量: {muxedStreams.Count}");
            foreach (var s in muxedStreams.Take(5))
            {
                progress?.Report($"[YouTubeService]   混合流: {s.Container} - {s.Size.Bytes / 1024 / 1024:F2} MB");
            }

            var videoOnlyStreams = streamManifest.GetVideoOnlyStreams().ToList();
            progress?.Report($"[YouTubeService] 可用视频流数量: {videoOnlyStreams.Count}");
            foreach (var s in videoOnlyStreams.Take(5))
            {
                progress?.Report($"[YouTubeService]   视频流: {s.Container} - {s.Size.Bytes / 1024 / 1024:F2} MB");
            }

            var audioOnlyStreams = streamManifest.GetAudioOnlyStreams().ToList();
            progress?.Report($"[YouTubeService] 可用音频流数量: {audioOnlyStreams.Count}");
            foreach (var s in audioOnlyStreams.Take(5))
            {
                progress?.Report($"[YouTubeService]   音频流: {s.Container} - {s.Bitrate} - {s.Size.Bytes / 1024 / 1024:F2} MB");
            }

            var videoStreamInfo = videoOnlyStreams
                .OrderByDescending(s => s.Size)
                .FirstOrDefault(s => s.Size.Bytes > 0);

            var audioStreamInfo = audioOnlyStreams
                .OrderByDescending(s => s.Bitrate)
                .FirstOrDefault(s => s.Size.Bytes > 0);

            progress?.Report($"[YouTubeService] 选择后的视频流: {videoStreamInfo?.Container} - {videoStreamInfo?.Size.Bytes / 1024 / 1024:F2} MB");
            progress?.Report($"[YouTubeService] 选择后的音频流: {audioStreamInfo?.Container} - {audioStreamInfo?.Bitrate} - {audioStreamInfo?.Size.Bytes / 1024 / 1024:F2} MB");

            if (videoStreamInfo == null || audioStreamInfo == null || videoStreamInfo.Size.Bytes == 0)
            {
                progress?.Report("[YouTubeService] 视频或音频流无效，尝试混合流...");
                var combinedStreams = muxedStreams
                    .OrderByDescending(s => s.Size)
                    .FirstOrDefault(s => s.Size.Bytes > 0);
                if (combinedStreams != null)
                {
                    progress?.Report($"[YouTubeService] 使用混合流: {combinedStreams?.Container} - {combinedStreams?.Size.Bytes / 1024 / 1024:F2} MB");
                    await _youtubeClient.Videos.Streams.DownloadAsync(combinedStreams, tempVideoPath, null, cancellationToken);

                    progress?.Report($"[YouTubeService] 下载后检查文件是否存在: {File.Exists(tempVideoPath)}");
                    if (!File.Exists(tempVideoPath))
                    {
                        throw new InvalidOperationException($"视频下载失败: 混合流文件未创建。临时路径: {tempVideoPath}");
                    }

                    var downloadedSize = new FileInfo(tempVideoPath).Length;
                    progress?.Report($"[YouTubeService] 混合流下载完成: {downloadedSize / 1024 / 1024:F2} MB");

                    if (tempVideoPath != outputPath)
                    {
                        progress?.Report($"[YouTubeService] 移动临时文件到目标路径...");
                        if (File.Exists(outputPath))
                        {
                            progress?.Report($"[YouTubeService] 删除已存在的目标文件: {outputPath}");
                            File.Delete(outputPath);
                        }
                        File.Move(tempVideoPath, outputPath);
                    }

                    var mergedFileInfo = new FileInfo(outputPath);
                    progress?.Report($"[YouTubeService] 视频下载完成: {mergedFileInfo.Length / 1024 / 1024:F2} MB");
                    progress?.Report($"[YouTubeService] 最终文件路径: {outputPath}");
                    progress?.Report($"[YouTubeService] 最终文件是否存在: {File.Exists(outputPath)}");
                    return outputPath;
                }
                throw new InvalidOperationException("未找到可用的视频流或音频流");
            }

            var totalSize = videoStreamInfo.Size.Bytes + audioStreamInfo.Size.Bytes;
            progress?.Report($"[YouTubeService] 视频总大小: {totalSize / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 下载视频流...");
            var videoProgress = new Progress<double>(p =>
            {
                progress?.Report($"[YouTubeService] 原始进度值: {p:F4}");
                if (p >= 0.001)
                {
                    var elapsed = DateTime.Now - startTime;
                    var estimatedTotal = elapsed.TotalSeconds / p;
                    var remaining = TimeSpan.FromSeconds(estimatedTotal - elapsed.TotalSeconds);
                    progress?.Report($"[YouTubeService] 视频进度: {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                    progress?.ReportProgress(p * 45, $"正在下载视频流... {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                }
            });
            await _youtubeClient.Videos.Streams.DownloadAsync(videoStreamInfo, tempVideoPath, videoProgress, cancellationToken);
            progress?.Report($"[YouTubeService] 视频流下载完成: {File.Exists(tempVideoPath)} - {new FileInfo(tempVideoPath).Length / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 下载音频流...");
            var audioProgress = new Progress<double>(p =>
            {
                progress?.Report($"[YouTubeService] 原始进度值: {p:F4}");
                if (p >= 0.001)
                {
                    var elapsed = DateTime.Now - startTime;
                    var estimatedTotal = elapsed.TotalSeconds / p;
                    var remaining = TimeSpan.FromSeconds(estimatedTotal - elapsed.TotalSeconds);
                    progress?.Report($"[YouTubeService] 音频进度: {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                    progress?.ReportProgress(45 + p * 45, $"正在下载音频流... {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                }
            });
            await _youtubeClient.Videos.Streams.DownloadAsync(audioStreamInfo, tempAudioPath, audioProgress, cancellationToken);
            progress?.Report($"[YouTubeService] 音频流下载完成: {File.Exists(tempAudioPath)} - {new FileInfo(tempAudioPath).Length / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 合并视频和音频...");
            var mergeArgs = $"-i \"{tempVideoPath}\" -i \"{tempAudioPath}\" -c copy -map 0:v:0 -map 1:a:0 -y \"{tempMergedPath}\"";
            progress?.Report($"[YouTubeService] FFmpeg 命令: {mergeArgs}");

            var mergeResult = await Ffmpeg.ExecuteCommandAsync(mergeArgs, TimeSpan.FromMinutes(10));
            progress?.Report($"[YouTubeService] FFmpeg 合并结果: {mergeResult}");
            progress?.Report($"[YouTubeService] 合并后文件是否存在: {File.Exists(tempMergedPath)}");

            if (File.Exists(tempMergedPath))
            {
                var mergedSize = new FileInfo(tempMergedPath).Length;
                progress?.Report($"[YouTubeService] 合并后文件大小: {mergedSize / 1024 / 1024:F2} MB");

                progress?.Report("[YouTubeService] 清理临时文件...");
                if (File.Exists(tempVideoPath)) { File.Delete(tempVideoPath); progress?.Report($"[YouTubeService] 已删除: {tempVideoPath}"); }
                if (File.Exists(tempAudioPath)) { File.Delete(tempAudioPath); progress?.Report($"[YouTubeService] 已删除: {tempAudioPath}"); }
                if (File.Exists(outputPath)) { File.Delete(outputPath); progress?.Report($"[YouTubeService] 已删除已存在的目标: {outputPath}"); }

                progress?.Report($"[YouTubeService] 移动合并文件到目标路径: {outputPath}");
                File.Move(tempMergedPath, outputPath);
            }
            else
            {
                progress?.Warning("[YouTubeService] 第一次合并失败，尝试使用转码合并...");
                var convertArgs = $"-i \"{tempVideoPath}\" -i \"{tempAudioPath}\" -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 -y \"{outputPath}\"";
                var convertResult = await Ffmpeg.ExecuteCommandAsync(convertArgs, TimeSpan.FromMinutes(10));
                progress?.Report($"[YouTubeService] FFmpeg 转码结果: {convertResult}");

                progress?.Report("[YouTubeService] 清理临时文件...");
                if (File.Exists(tempVideoPath)) { File.Delete(tempVideoPath); progress?.Report($"[YouTubeService] 已删除: {tempVideoPath}"); }
                if (File.Exists(tempAudioPath)) { File.Delete(tempAudioPath); progress?.Report($"[YouTubeService] 已删除: {tempAudioPath}"); }
            }

            progress?.Report($"[YouTubeService] 最终检查: outputPath={outputPath}, exists={File.Exists(outputPath)}");

            if (!File.Exists(outputPath))
            {
                progress?.Error($"[YouTubeService] 错误: 文件不存在！列出目录内容:");
                if (Directory.Exists(outputDir))
                {
                    foreach (var f in Directory.GetFiles(outputDir))
                    {
                        progress?.Report($"[YouTubeService]   - {f}");
                    }
                }
                throw new InvalidOperationException($"视频下载失败: 合并后的文件未创建。目标路径: {outputPath}");
            }

            var fileInfo = new FileInfo(outputPath);
            progress?.Report($"[YouTubeService] 视频下载完成: {fileInfo.Length / 1024 / 1024:F2} MB");
            progress?.Report($"[YouTubeService] 最终文件: {outputPath}");
            progress?.Report($"[YouTubeService] ============================================");
            progress?.ReportProgress(100, "视频下载完成");
        }
        catch (OperationCanceledException)
        {
            progress?.Report("[YouTubeService] 下载已取消");
            foreach (var tempFile in new[] { tempVideoPath, tempAudioPath, tempMergedPath })
            {
                if (File.Exists(tempFile))
                {
                    File.Delete(tempFile);
                    progress?.Report($"[YouTubeService] 已删除临时文件: {tempFile}");
                }
            }
            throw;
        }
        catch (Exception ex)
        {
            progress?.Error($"[YouTubeService] 下载失败: {ex.Message}");
            progress?.Report($"[YouTubeService] 堆栈跟踪: {ex.StackTrace}");
            foreach (var tempFile in new[] { tempVideoPath, tempAudioPath, tempMergedPath })
            {
                if (File.Exists(tempFile))
                {
                    File.Delete(tempFile);
                    progress?.Report($"[YouTubeService] 已删除临时文件: {tempFile}");
                }
            }
            throw new InvalidOperationException($"视频下载失败: {ex.Message}", ex);
        }

        return outputPath;
    }

    public async Task<string> DownloadVideoAsync(string url, YouTubeVideoStream? videoStream, YouTubeAudio? audioStream, string outputPath,  CancellationToken cancellationToken = default)
    {
        progress?.Report($"[YouTubeService] ============================================");
        progress?.Report($"[YouTubeService] 开始下载视频（直接使用流对象）...");
        progress?.Report($"[YouTubeService] URL: {url}");
        progress?.Report($"[YouTubeService] 输出路径: {outputPath}");

        var video = await _youtubeClient.Videos.GetAsync(url);
        var title = string.Join("", video.Title.Split(Path.GetInvalidFileNameChars()));
        var outputDir = Path.GetDirectoryName(outputPath) ?? ".";
        var tempVideoPath = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}_video.mp4");
        var tempAudioPath = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}_audio.m4a");
        var tempMergedPath = $"{tempVideoPath}_merged.mp4";

        progress?.Report($"[YouTubeService] 临时视频路径: {tempVideoPath}");
        progress?.Report($"[YouTubeService] 临时音频路径: {tempAudioPath}");
        progress?.Report($"[YouTubeService] 临时合并路径: {tempMergedPath}");

        var startTime = DateTime.Now;

        try
        {
            var streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(url, verifyContentLength: false);

            var videoOnlyStreams = streamManifest.GetVideoOnlyStreams().ToList();
            var audioOnlyStreams = streamManifest.GetAudioOnlyStreams().ToList();

            progress?.Report($"[YouTubeService] 可用视频流数量: {videoOnlyStreams.Count}");
            progress?.Report($"[YouTubeService] 可用音频流数量: {audioOnlyStreams.Count}");

            var videoStreamInfo = videoStream != null ?
                videoOnlyStreams.FirstOrDefault(s => s.Url == videoStream.DownloadUrl) :
                videoOnlyStreams.OrderByDescending(s => s.Size).FirstOrDefault(s => s.Size.Bytes > 0);

            var audioStreamInfo = audioStream != null ?
                audioOnlyStreams.FirstOrDefault(s => s.Url == audioStream.DownloadUrl) :
                audioOnlyStreams.OrderByDescending(s => s.Bitrate).FirstOrDefault(s => s.Size.Bytes > 0);

            progress?.Report($"[YouTubeService] 选择后的视频流: {videoStreamInfo?.Container} - {videoStreamInfo?.Size.Bytes / 1024 / 1024:F2} MB");
            progress?.Report($"[YouTubeService] 选择后的音频流: {audioStreamInfo?.Container} - {audioStreamInfo?.Bitrate} - {audioStreamInfo?.Size.Bytes / 1024 / 1024:F2} MB");

            if (videoStreamInfo == null || audioStreamInfo == null || videoStreamInfo.Size.Bytes == 0)
            {
                var muxedStreams = streamManifest.GetMuxedStreams().ToList();
                var combinedStreams = muxedStreams.OrderByDescending(s => s.Size).FirstOrDefault(s => s.Size.Bytes > 0);
                if (combinedStreams != null)
                {
                    progress?.Report($"[YouTubeService] 使用混合流: {combinedStreams?.Container} - {combinedStreams?.Size.Bytes / 1024 / 1024:F2} MB");
                    await _youtubeClient.Videos.Streams.DownloadAsync(combinedStreams, tempVideoPath, null, cancellationToken);

                    progress?.Report($"[YouTubeService] 下载后检查文件是否存在: {File.Exists(tempVideoPath)}");
                    if (!File.Exists(tempVideoPath))
                    {
                        throw new InvalidOperationException($"视频下载失败: 混合流文件未创建。临时路径: {tempVideoPath}");
                    }

                    var downloadedSize = new FileInfo(tempVideoPath).Length;
                    progress?.Report($"[YouTubeService] 混合流下载完成: {downloadedSize / 1024 / 1024:F2} MB");

                    if (tempVideoPath != outputPath)
                    {
                        progress?.Report($"[YouTubeService] 移动临时文件到目标路径...");
                        if (File.Exists(outputPath))
                        {
                            progress?.Report($"[YouTubeService] 删除已存在的目标文件: {outputPath}");
                            File.Delete(outputPath);
                        }
                        File.Move(tempVideoPath, outputPath);
                    }

                    var muxedFileInfo = new FileInfo(outputPath);
                    progress?.Report($"[YouTubeService] 视频下载完成: {muxedFileInfo.Length / 1024 / 1024:F2} MB");
                    progress?.Report($"[YouTubeService] 最终文件路径: {outputPath}");
                    progress?.Report($"[YouTubeService] 最终文件是否存在: {File.Exists(outputPath)}");
                    return outputPath;
                }
                throw new InvalidOperationException("未找到可用的视频流或音频流");
            }

            var totalSize = videoStreamInfo.Size.Bytes + audioStreamInfo.Size.Bytes;
            progress?.Report($"[YouTubeService] 视频总大小: {totalSize / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 下载视频流...");
            var videoProgress = new Progress<double>(p =>
            {
                progress?.Report($"[YouTubeService] 原始进度值: {p:F4}");
                if (p >= 0.001)
                {
                    var elapsed = DateTime.Now - startTime;
                    var estimatedTotal = elapsed.TotalSeconds / p;
                    var remaining = TimeSpan.FromSeconds(estimatedTotal - elapsed.TotalSeconds);
                    progress?.Report($"[YouTubeService] 视频进度: {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                    progress?.ReportProgress(p * 45, $"正在下载视频流... {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                }
            });
            await _youtubeClient.Videos.Streams.DownloadAsync(videoStreamInfo, tempVideoPath, videoProgress, cancellationToken);
            progress?.Report($"[YouTubeService] 视频流下载完成: {File.Exists(tempVideoPath)} - {new FileInfo(tempVideoPath).Length / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 下载音频流...");
            var audioProgress = new Progress<double>(p =>
            {
                progress?.Report($"[YouTubeService] 原始进度值: {p:F4}");
                if (p >= 0.001)
                {
                    var elapsed = DateTime.Now - startTime;
                    var estimatedTotal = elapsed.TotalSeconds / p;
                    var remaining = TimeSpan.FromSeconds(estimatedTotal - elapsed.TotalSeconds);
                    progress?.Report($"[YouTubeService] 音频进度: {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                    progress?.ReportProgress(45 + p * 45, $"正在下载音频流... {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                }
            });
            await _youtubeClient.Videos.Streams.DownloadAsync(audioStreamInfo, tempAudioPath, audioProgress, cancellationToken);
            progress?.Report($"[YouTubeService] 音频流下载完成: {File.Exists(tempAudioPath)} - {new FileInfo(tempAudioPath).Length / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 合并视频和音频...");
            var mergeArgs = $"-i \"{tempVideoPath}\" -i \"{tempAudioPath}\" -c copy -map 0:v:0 -map 1:a:0 -y \"{tempMergedPath}\"";
            progress?.Report($"[YouTubeService] FFmpeg 命令: {mergeArgs}");

            await Ffmpeg.ExecuteCommandAsync(mergeArgs);
            progress?.Report($"[YouTubeService] 合并完成");

            if (File.Exists(tempVideoPath))
            {
                File.Delete(tempVideoPath);
            }

            if (File.Exists(tempAudioPath))
            {
                File.Delete(tempAudioPath);
            }

            if (tempMergedPath != outputPath)
            {
                progress?.Report($"[YouTubeService] 移动合并后的文件到目标路径...");
                if (File.Exists(outputPath))
                {
                    progress?.Report($"[YouTubeService] 删除已存在的目标文件: {outputPath}");
                    File.Delete(outputPath);
                }
                File.Move(tempMergedPath, outputPath);
            }

            var finalFileInfo = new FileInfo(outputPath);
            progress?.Report($"[YouTubeService] 视频下载完成: {finalFileInfo.Length / 1024 / 1024:F2} MB");
            progress?.Report($"[YouTubeService] 最终文件路径: {outputPath}");
            progress?.Report($"[YouTubeService] 最终文件是否存在: {File.Exists(outputPath)}");

            return outputPath;
        }
        catch (Exception ex)
        {
            progress?.Error($"[YouTubeService] 下载失败: {ex.Message}");
            progress?.Report($"[YouTubeService] 异常详情: {ex}");

            foreach (var tempFile in new[] { tempVideoPath, tempAudioPath, tempMergedPath })
            {
                if (File.Exists(tempFile))
                {
                    File.Delete(tempFile);
                    progress?.Report($"[YouTubeService] 已删除临时文件: {tempFile}");
                }
            }
            throw new InvalidOperationException($"视频下载失败: {ex.Message}", ex);
        }
    }

    public async Task<string> DownloadVideoAsync(string url, string videoQualityUrl, string audioQualityUrl, string outputPath, CancellationToken cancellationToken = default)
    {
        progress?.Report($"[YouTubeService] ============================================");
        progress?.Report($"[YouTubeService] 开始下载视频...");
        progress?.Report($"[YouTubeService] URL: {url}");
        progress?.Report($"[YouTubeService] 输出路径: {outputPath}");

        var video = await _youtubeClient.Videos.GetAsync(url);
        var title = string.Join("", video.Title.Split(Path.GetInvalidFileNameChars()));
        var outputDir = Path.GetDirectoryName(outputPath) ?? ".";
        var tempVideoPath = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}_video.mp4");
        var tempAudioPath = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}_audio.m4a");
        var tempMergedPath = $"{tempVideoPath}_merged.mp4";

        progress?.Report($"[YouTubeService] 临时视频路径: {tempVideoPath}");
        progress?.Report($"[YouTubeService] 临时音频路径: {tempAudioPath}");
        progress?.Report($"[YouTubeService] 临时合并路径: {tempMergedPath}");

        var startTime = DateTime.Now;

        try
        {
            var streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(url, verifyContentLength: false);

            var videoOnlyStreams = streamManifest.GetVideoOnlyStreams().ToList();
            var audioOnlyStreams = streamManifest.GetAudioOnlyStreams().ToList();

            progress?.Report($"[YouTubeService] videoQualityUrl 长度: {videoQualityUrl?.Length ?? 0}");
            progress?.Report($"[YouTubeService] audioQualityUrl 长度: {audioQualityUrl?.Length ?? 0}");

            progress?.Report($"[YouTubeService] 可用视频流数量: {videoOnlyStreams.Count}");
            progress?.Report($"[YouTubeService] 可用音频流数量: {audioOnlyStreams.Count}");

            if (!string.IsNullOrEmpty(videoQualityUrl))
            {
                progress?.Report($"[YouTubeService] videoQualityUrl 为空，将使用最大视频流");
            }
            else
            {
                progress?.Report($"[YouTubeService] videoQualityUrl 前100字符: {videoQualityUrl.Substring(0, Math.Min(100, videoQualityUrl.Length))}");
            }

            var videoStreamInfo = videoOnlyStreams.FirstOrDefault(s => s.Url == videoQualityUrl);
            var audioStreamInfo = audioOnlyStreams.FirstOrDefault(s => s.Url == audioQualityUrl);

            progress?.Report($"[YouTubeService] videoStreamInfo 匹配结果: {videoStreamInfo != null}");
            progress?.Report($"[YouTubeService] audioStreamInfo 匹配结果: {audioStreamInfo != null}");

            if (videoStreamInfo == null && !string.IsNullOrEmpty(videoQualityUrl))
            {
                progress?.Report($"[YouTubeService] 尝试查找视频流 URL 包含: {videoQualityUrl.Substring(0, Math.Min(50, videoQualityUrl.Length))}...");
                foreach (var stream in videoOnlyStreams.Take(3))
                {
                    progress?.Report($"[YouTubeService]   视频流 URL: {stream.Url.Substring(0, Math.Min(50, stream.Url.Length))}...");
                    progress?.Report($"[YouTubeService]   完整 URL: {stream.Url}");
                }
                progress?.Report($"[YouTubeService]   用户选择的 URL: {videoQualityUrl}");

                progress?.Report($"[YouTubeService] 尝试使用 itag 匹配...");
                var itagMatch = System.Text.RegularExpressions.Regex.Match(videoQualityUrl, @"itag=(\d+)");
                if (itagMatch.Success)
                {
                    var itag = int.Parse(itagMatch.Groups[1].Value);
                    progress?.Report($"[YouTubeService]   用户选择的 itag: {itag}");
                    videoStreamInfo = videoOnlyStreams.FirstOrDefault(s =>
                    {
                        var streamItagMatch = System.Text.RegularExpressions.Regex.Match(s.Url, @"itag=(\d+)");
                        return streamItagMatch.Success && int.Parse(streamItagMatch.Groups[1].Value) == itag;
                    });
                    progress?.Report($"[YouTubeService]   itag 匹配结果: {videoStreamInfo != null}");
                }
            }

            if (videoStreamInfo == null)
            {
                progress?.Warning($"[YouTubeService] 视频流匹配失败，回退到最大视频流");
                videoStreamInfo = videoOnlyStreams.OrderByDescending(s => s.Size).FirstOrDefault(s => s.Size.Bytes > 0);
            }

            if (audioStreamInfo == null)
            {
                progress?.Warning($"[YouTubeService] 音频流匹配失败，回退到最高码率音频流");
                audioStreamInfo = audioOnlyStreams.OrderByDescending(s => s.Bitrate).FirstOrDefault(s => s.Size.Bytes > 0);
            }

            progress?.Report($"[YouTubeService] 选择后的视频流: {videoStreamInfo?.Container} - {videoStreamInfo?.Size.Bytes / 1024 / 1024:F2} MB");
            progress?.Report($"[YouTubeService] 选择后的音频流: {audioStreamInfo?.Container} - {audioStreamInfo?.Bitrate} - {audioStreamInfo?.Size.Bytes / 1024 / 1024:F2} MB");

            if (videoStreamInfo == null || audioStreamInfo == null || videoStreamInfo.Size.Bytes == 0)
            {
                var muxedStreams = streamManifest.GetMuxedStreams().ToList();
                var combinedStreams = muxedStreams.OrderByDescending(s => s.Size).FirstOrDefault(s => s.Size.Bytes > 0);
                if (combinedStreams != null)
                {
                    progress?.Report($"[YouTubeService] 使用混合流: {combinedStreams?.Container} - {combinedStreams?.Size.Bytes / 1024 / 1024:F2} MB");
                    await _youtubeClient.Videos.Streams.DownloadAsync(combinedStreams, tempVideoPath, null, cancellationToken);

                    progress?.Report($"[YouTubeService] 下载后检查文件是否存在: {File.Exists(tempVideoPath)}");
                    if (!File.Exists(tempVideoPath))
                    {
                        throw new InvalidOperationException($"视频下载失败: 混合流文件未创建。临时路径: {tempVideoPath}");
                    }

                    var downloadedSize = new FileInfo(tempVideoPath).Length;
                    progress?.Report($"[YouTubeService] 混合流下载完成: {downloadedSize / 1024 / 1024:F2} MB");

                    if (tempVideoPath != outputPath)
                    {
                        progress?.Report($"[YouTubeService] 移动临时文件到目标路径...");
                        if (File.Exists(outputPath))
                        {
                            progress?.Report($"[YouTubeService] 删除已存在的目标文件: {outputPath}");
                            File.Delete(outputPath);
                        }
                        File.Move(tempVideoPath, outputPath);
                    }

                    var finalFileInfo = new FileInfo(outputPath);
                    progress?.Report($"[YouTubeService] 视频下载完成: {finalFileInfo.Length / 1024 / 1024:F2} MB");
                    progress?.Report($"[YouTubeService] 最终文件路径: {outputPath}");
                    progress?.Report($"[YouTubeService] 最终文件是否存在: {File.Exists(outputPath)}");
                    return outputPath;
                }
                throw new InvalidOperationException("未找到可用的视频流或音频流");
            }

            var totalSize = videoStreamInfo.Size.Bytes + audioStreamInfo.Size.Bytes;
            progress?.Report($"[YouTubeService] 视频总大小: {totalSize / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 下载视频流...");
            var videoProgress = new Progress<double>(p =>
            {
                var elapsed = DateTime.Now - startTime;
                var estimatedTotal = elapsed.TotalSeconds / p;
                var remaining = TimeSpan.FromSeconds(estimatedTotal - elapsed.TotalSeconds);
                progress?.Report($"[YouTubeService] 视频进度: {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                progress?.ReportProgress(p * 45, $"正在下载视频流... {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
            });
            await _youtubeClient.Videos.Streams.DownloadAsync(videoStreamInfo, tempVideoPath, videoProgress, cancellationToken);
            progress?.Report($"[YouTubeService] 视频流下载完成: {File.Exists(tempVideoPath)} - {new FileInfo(tempVideoPath).Length / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 下载音频流...");
            var audioProgress = new Progress<double>(p =>
            {
                var elapsed = DateTime.Now - startTime;
                var estimatedTotal = elapsed.TotalSeconds / p;
                var remaining = TimeSpan.FromSeconds(estimatedTotal - elapsed.TotalSeconds);
                progress?.Report($"[YouTubeService] 音频进度: {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
                progress?.ReportProgress(45 + p * 45, $"正在下载音频流... {p * 100:F1}% | 剩余: {remaining:m\\:ss}");
            });
            await _youtubeClient.Videos.Streams.DownloadAsync(audioStreamInfo, tempAudioPath, audioProgress, cancellationToken);
            progress?.Report($"[YouTubeService] 音频流下载完成: {File.Exists(tempAudioPath)} - {new FileInfo(tempAudioPath).Length / 1024 / 1024:F2} MB");

            progress?.Report("[YouTubeService] 合并视频和音频...");
            var mergeArgs = $"-i \"{tempVideoPath}\" -i \"{tempAudioPath}\" -c copy -map 0:v:0 -map 1:a:0 -y \"{tempMergedPath}\"";
            progress?.Report($"[YouTubeService] FFmpeg 命令: {mergeArgs}");

            var mergeResult = await Ffmpeg.ExecuteCommandAsync(mergeArgs, TimeSpan.FromMinutes(10));
            progress?.Report($"[YouTubeService] FFmpeg 合并结果: {mergeResult}");
            progress?.Report($"[YouTubeService] 合并后文件是否存在: {File.Exists(tempMergedPath)}");

            if (File.Exists(tempMergedPath))
            {
                var mergedSize = new FileInfo(tempMergedPath).Length;
                progress?.Report($"[YouTubeService] 合并后文件大小: {mergedSize / 1024 / 1024:F2} MB");

                progress?.Report("[YouTubeService] 清理临时文件...");
                if (File.Exists(tempVideoPath)) { File.Delete(tempVideoPath); progress?.Report($"[YouTubeService] 已删除: {tempVideoPath}"); }
                if (File.Exists(tempAudioPath)) { File.Delete(tempAudioPath); progress?.Report($"[YouTubeService] 已删除: {tempAudioPath}"); }
                if (File.Exists(outputPath)) { File.Delete(outputPath); progress?.Report($"[YouTubeService] 已删除已存在的目标: {outputPath}"); }

                progress?.Report($"[YouTubeService] 移动合并文件到目标路径: {outputPath}");
                File.Move(tempMergedPath, outputPath);
            }
            else
            {
                progress?.Warning("[YouTubeService] 第一次合并失败，尝试使用转码合并...");
                var convertArgs = $"-i \"{tempVideoPath}\" -i \"{tempAudioPath}\" -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 -y \"{outputPath}\"";
                var convertResult = await Ffmpeg.ExecuteCommandAsync(convertArgs, TimeSpan.FromMinutes(10));
                progress?.Report($"[YouTubeService] FFmpeg 转码结果: {convertResult}");

                progress?.Report("[YouTubeService] 清理临时文件...");
                if (File.Exists(tempVideoPath)) { File.Delete(tempVideoPath); progress?.Report($"[YouTubeService] 已删除: {tempVideoPath}"); }
                if (File.Exists(tempAudioPath)) { File.Delete(tempAudioPath); progress?.Report($"[YouTubeService] 已删除: {tempAudioPath}"); }
            }

            progress?.Report($"[YouTubeService] 最终检查: outputPath={outputPath}, exists={File.Exists(outputPath)}");

            if (!File.Exists(outputPath))
            {
                progress?.Error($"[YouTubeService] 错误: 文件不存在！列出目录内容:");
                if (Directory.Exists(outputDir))
                {
                    foreach (var f in Directory.GetFiles(outputDir))
                    {
                        progress?.Report($"[YouTubeService]   - {f}");
                    }
                }
                throw new InvalidOperationException($"视频下载失败: 合并后的文件未创建。目标路径: {outputPath}");
            }

            var fileInfo = new FileInfo(outputPath);
            progress?.Report($"[YouTubeService] 视频下载完成: {fileInfo.Length / 1024 / 1024:F2} MB");
            progress?.Report($"[YouTubeService] 最终文件: {outputPath}");
            progress?.Report($"[YouTubeService] ============================================");
            progress?.ReportProgress(100, "视频下载完成");
        }
        catch (OperationCanceledException)
        {
            progress?.Report("[YouTubeService] 下载已取消");
            foreach (var tempFile in new[] { tempVideoPath, tempAudioPath, tempMergedPath })
            {
                if (File.Exists(tempFile))
                {
                    File.Delete(tempFile);
                    progress?.Report($"[YouTubeService] 已删除临时文件: {tempFile}");
                }
            }
            throw;
        }
        catch (Exception ex)
        {
            progress?.Error($"[YouTubeService] 下载失败: {ex.Message}");
            progress?.Error($"[YouTubeService] 堆栈跟踪: {ex.StackTrace}");
            foreach (var tempFile in new[] { tempVideoPath, tempAudioPath, tempMergedPath })
            {
                if (File.Exists(tempFile))
                {
                    File.Delete(tempFile);
                    progress?.Error($"[YouTubeService] 已删除临时文件: {tempFile}");
                }
            }
            throw new InvalidOperationException($"视频下载失败: {ex.Message}", ex);
        }

        return outputPath;
    }

    public async Task<string> DownloadAudioAsync(string url, string outputPath,  CancellationToken cancellationToken = default)
    {
        progress?.Report($"[YouTubeService] 开始下载音频...");
        progress?.Report($"  URL: {url}");
        progress?.Report($"  输出路径: {outputPath}");

        var video = await _youtubeClient.Videos.GetAsync(url);
        var title = string.Join("", video.Title.Split(Path.GetInvalidFileNameChars()));
        var outputDir = Path.GetDirectoryName(outputPath) ?? ".";
        var tempOutput = Path.Combine(outputDir, $"{title}.{DateTime.Now.Ticks}.m4a");

        var startTime = DateTime.Now;

        var progressReporter = new Progress<double>(p =>
        {
            var elapsed = DateTime.Now - startTime;
            var speed = p > 0 ? elapsed.TotalSeconds / p * (1 - p) : 0;
            var remaining = TimeSpan.FromSeconds(speed);

            progress?.Report($"[YouTubeService] 下载进度: {p * 50:F1}% | 剩余: {remaining:m\\:ss}");
            progress?.ReportProgress(p * 50, $"正在下载音频... {p * 50:F1}% | 剩余: {remaining:m\\:ss}");
        });

        try
        {
            var streamManifest = await _youtubeClient.Videos.Streams.GetManifestAsync(url, verifyContentLength: false);
            var audioStream = streamManifest.GetAudioOnlyStreams()
                .OrderByDescending(s => s.Bitrate)
                .FirstOrDefault(s => s.Container.Name == "m4a" || s.Container.Name == "webm");

            if (audioStream == null)
            {
                audioStream = streamManifest.GetAudioOnlyStreams().OrderByDescending(s => s.Bitrate).FirstOrDefault();
            }

            if (audioStream != null)
            {
                progress?.Report($"[YouTubeService] 音频大小: {audioStream.Size.Bytes / 1024 / 1024:F2} MB");
                await _youtubeClient.Videos.Streams.DownloadAsync(audioStream, tempOutput, progressReporter, cancellationToken);
            }
            else
            {
                throw new Exception("未找到可用的音频流");
            }

            if (File.Exists(tempOutput))
            {
                var tempFileInfo = new FileInfo(tempOutput);
                progress?.Report($"[YouTubeService] 原始音频下载完成: {tempFileInfo.Length / 1024 / 1024:F2} MB");

                progress?.Report($"[YouTubeService] 开始转换为 WAV 格式 (16kHz, 单声道)...");
                var convertArgs = $"-i \"{tempOutput}\" -acodec pcm_s16le -ar 16000 -ac 1 -y \"{outputPath}\"";
                await Ffmpeg.ExecuteCommandAsync(convertArgs);

                File.Delete(tempOutput);

                if (File.Exists(outputPath))
                {
                    var wavFileInfo = new FileInfo(outputPath);
                    progress?.Report($"[YouTubeService] WAV 转换完成: {wavFileInfo.Length / 1024 / 1024:F2} MB");
                    progress?.ReportProgress(100, "音频下载完成");
                }
            }
        }
        catch (OperationCanceledException)
        {
            progress?.Report("[YouTubeService] 下载已取消");
            if (File.Exists(tempOutput)) File.Delete(tempOutput);
            throw;
        }
        catch
        {
            if (File.Exists(tempOutput)) File.Delete(tempOutput);
            throw;
        }

        return outputPath;
    }

    public async Task<string> DownloadSubtitleAsync(string url, string languageCode, string outputPath)
    {
        progress?.Report($"[YouTubeService] 开始下载字幕...");
        progress?.Report($"  语言代码: {languageCode}");
        progress?.Report($"  输出路径: {outputPath}");

        try
        {
            var trackManifest = await _youtubeClient.Videos.ClosedCaptions.GetManifestAsync(url);
            var targetTrackInfo = trackManifest.GetByLanguage(languageCode);

            if (targetTrackInfo == null)
            {
                progress?.Report($"[YouTubeService] 未找到语言代码为 '{languageCode}' 的字幕");
                throw new Exception($"未找到语言代码为 '{languageCode}' 的字幕");
            }

            await _youtubeClient.Videos.ClosedCaptions.DownloadAsync(targetTrackInfo, outputPath);

            if (File.Exists(outputPath))
            {
                var fileInfo = new FileInfo(outputPath);
                progress?.Report($"[YouTubeService] 字幕下载完成: {fileInfo.Length / 1024:F2} KB");
            }
        }
        catch (Exception ex)
        {
            progress?.Error($"[YouTubeService] 字幕下载失败: {ex.Message}");
            throw;
        }

        return outputPath;
    }

    public async Task<List<YouTubeSubtitle>> GetAvailableSubtitlesAsync(string url)
    {
        var video = await GetVideoInfoAsync(url);
        return video.AvailableSubtitles;
    }

    public async Task<List<YouTubeAudio>> GetAvailableAudiosAsync(string url)
    {
        var video = await GetVideoInfoAsync(url);
        return video.AvailableAudios;
    }

    private static string GetFfmpegPath()
    {
        return Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "ffmpeg", "ffmpeg.exe");
    }

    private static string ExtractVideoId(string url)
    {
        var patterns = new[]
        {
            @"youtube\.com\/watch\?v=([^""&?\/\s]{11})",
            @"youtube\.com\/embed\/([^""&?\/\s]{11})",
            @"youtube\.com\/v\/([^""&?\/\s]{11})",
            @"youtu\.be\/([^""&?\/\s]{11})"
        };

        foreach (var pattern in patterns)
        {
            var match = Regex.Match(url, pattern);
            if (match.Success)
                return match.Groups[1].Value;
        }

        return string.Empty;
    }
}