# WPF 多个资源文件定义控件行为

## 核心答案

**是的，可以定义多个 ResourceDictionary 文件，同时指定一个控件的行为。**

## 实现方式

### 方式 1：合并多个 ResourceDictionary

```xml
<!-- Generic.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls">

    <ResourceDictionary.MergedDictionaries>
        <ResourceDictionary Source="ControlStyles.xaml"/>
        <ResourceDictionary Source="ControlTemplates.xaml"/>
        <ResourceDictionary Source="ControlBehaviors.xaml"/>
        <ResourceDictionary Source="ControlAnimations.xaml"/>
    </ResourceDictionary.MergedDictionaries>

    <!-- 这里可以定义其他资源 -->
</ResourceDictionary>
```

### 方式 2：在不同文件中定义同一控件的样式

#### 文件 1：ControlStyles.xaml（样式）
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls">

    <Style TargetType="local:SegmentControl">
        <Setter Property="Background" Value="#F0F0F0"/>
        <Setter Property="BorderBrush" Value="#CCCCCC"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Cursor" Value="Hand"/>
        <Setter Property="Padding" Value="5"/>
    </Style>
</ResourceDictionary>
```

#### 文件 2：ControlTemplates.xaml（模板）
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls">

    <Style TargetType="local:SegmentControl">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="local:SegmentControl">
                    <Border x:Name="PART_Border"
                            Background="{TemplateBinding Background}"
                            BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            CornerRadius="3"
                            Margin="1">
                        <Grid>
                            <Path x:Name="PART_WaveformPath"
                                  Stroke="{Binding RowColor, RelativeSource={RelativeSource TemplatedParent}}"
                                  StrokeThickness="2"
                                  Fill="Transparent"
                                  Stretch="Fill"/>
                            <TextBlock Text="{Binding Item.Text}"
                                       Foreground="#333333"
                                       VerticalAlignment="Center"
                                       HorizontalAlignment="Left"
                                       TextTrimming="CharacterEllipsis"
                                       Padding="5"
                                       FontSize="11"/>
                        </Grid>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter TargetName="PART_Border" Property="Background" Value="#E8F4FD"/>
                            <Setter TargetName="PART_Border" Property="BorderBrush" Value="#0078D4"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>
```

#### 文件 3：ControlBehaviors.xaml（行为）
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls"
                    xmlns:behaviors="clr-namespace:TimeLine.Behaviors">

    <Style TargetType="local:SegmentControl">
        <Setter Property="behaviors:DragBehavior.IsEnabled" Value="True"/>
        <Setter Property="behaviors:ResizeBehavior.IsEnabled" Value="True"/>
        <Setter Property="behaviors:ClickBehavior.IsEnabled" Value="True"/>
    </Style>
</ResourceDictionary>
```

#### 文件 4：ControlAnimations.xaml（动画）
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls">

    <Style TargetType="local:SegmentControl">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="local:SegmentControl">
                    <Border x:Name="PART_Border">
                        <!-- 控件内容 -->
                    </Border>
                    <ControlTemplate.Triggers>
                        <EventTrigger RoutedEvent="MouseEnter">
                            <BeginStoryboard>
                                <Storyboard>
                                    <DoubleAnimation Storyboard.TargetName="PART_Border"
                                                   Storyboard.TargetProperty="Opacity"
                                                   To="0.8"
                                                   Duration="0:0:0.2"/>
                                </Storyboard>
                            </BeginStoryboard>
                        </EventTrigger>
                        <EventTrigger RoutedEvent="MouseLeave">
                            <BeginStoryboard>
                                <Storyboard>
                                    <DoubleAnimation Storyboard.TargetName="PART_Border"
                                                   Storyboard.TargetProperty="Opacity"
                                                   To="1.0"
                                                   Duration="0:0:0.2"/>
                                </Storyboard>
                            </BeginStoryboard>
                        </EventTrigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>
```

### 方式 3：使用 BasedOn 继承样式

#### 基础样式：BaseStyles.xaml
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls">

    <!-- 基础样式 -->
    <Style x:Key="BaseSegmentStyle" TargetType="local:SegmentControl">
        <Setter Property="Background" Value="#F0F0F0"/>
        <Setter Property="BorderBrush" Value="#CCCCCC"/>
        <Setter Property="BorderThickness" Value="1"/>
        <Setter Property="Cursor" Value="Hand"/>
        <Setter Property="Padding" Value="5"/>
    </Style>
</ResourceDictionary>
```

#### 扩展样式：ExtendedStyles.xaml
```xml
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:local="clr-namespace:TimeLine.Controls">

    <!-- 继承基础样式，添加模板 -->
    <Style TargetType="local:SegmentControl" BasedOn="{StaticResource BaseSegmentStyle}">
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="local:SegmentControl">
                    <Border x:Name="PART_Border"
                            Background="{TemplateBinding Background}"
                            BorderBrush="{TemplateBinding BorderBrush}"
                            BorderThickness="{TemplateBinding BorderThickness}"
                            CornerRadius="3"
                            Margin="1">
                        <!-- 控件内容 -->
                    </Border>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>
```

## 样式合并规则

### 1. **属性合并**

当多个文件中定义了同一控件的样式时，WPF 会按照以下规则合并：

```xml
<!-- 文件 1 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Background" Value="#F0F0F0"/>
    <Setter Property="BorderBrush" Value="#CCCCCC"/>
    <Setter Property="BorderThickness" Value="1"/>
</Style>

<!-- 文件 2 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Cursor" Value="Hand"/>
    <Setter Property="Padding" Value="5"/>
</Style>

<!-- 合并结果（取决于加载顺序）：
     如果文件 2 在文件 1 之后加载，则：
     - Background = #F0F0F0（来自文件 1）
     - BorderBrush = #CCCCCC（来自文件 1）
     - BorderThickness = 1（来自文件 1）
     - Cursor = Hand（来自文件 2）
     - Padding = 5（来自文件 2）
-->
```

### 2. **属性覆盖**

如果多个文件中定义了同一属性，后加载的会覆盖先加载的：

```xml
<!-- 文件 1 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Background" Value="#F0F0F0"/>
</Style>

<!-- 文件 2 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Background" Value="#FFFFFF"/>  <!-- 覆盖文件 1 -->
</Style>

<!-- 合并结果：Background = #FFFFFF（来自文件 2） -->
```

### 3. **模板覆盖**

如果多个文件中定义了 Template，后加载的会完全覆盖先加载的：

```xml
<!-- 文件 1 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="local:SegmentControl">
                <Border>
                    <TextBlock Text="Template 1"/>
                </Border>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>

<!-- 文件 2 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="local:SegmentControl">
                <Border>
                    <TextBlock Text="Template 2"/>
                </Border>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>

<!-- 合并结果：Template = Template 2（完全覆盖） -->
```

## 资源查找顺序

WPF 按照以下顺序查找资源：

1. **元素本身**：元素的本地资源
2. **父元素**：向上遍历父元素的资源
3. **Application**：Application.Resources
4. **主题**：Generic.xaml 和其他主题文件
5. **系统**：系统默认资源

```xml
<!-- App.xaml -->
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="/TimeLine;component/Themes/Generic.xaml"/>
            <ResourceDictionary Source="/TimeLine;component/Themes/ControlStyles.xaml"/>
            <ResourceDictionary Source="/TimeLine;component/Themes/ControlTemplates.xaml"/>
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Application.Resources>
```

## 实际应用示例

### 示例 1：按功能模块分离文件

```
Themes/
├── Generic.xaml              # 主入口文件
├── Colors.xaml              # 颜色定义
├── Brushes.xaml             # 画刷定义
├── Converters.xaml          # 转换器定义
├── ControlStyles.xaml       # 控件样式
├── ControlTemplates.xaml     # 控件模板
├── ControlBehaviors.xaml    # 控件行为
├── ControlAnimations.xaml   # 控件动画
└── DataTemplates.xaml       # 数据模板
```

```xml
<!-- Generic.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <ResourceDictionary.MergedDictionaries>
        <ResourceDictionary Source="Colors.xaml"/>
        <ResourceDictionary Source="Brushes.xaml"/>
        <ResourceDictionary Source="Converters.xaml"/>
        <ResourceDictionary Source="ControlStyles.xaml"/>
        <ResourceDictionary Source="ControlTemplates.xaml"/>
        <ResourceDictionary Source="ControlBehaviors.xaml"/>
        <ResourceDictionary Source="ControlAnimations.xaml"/>
        <ResourceDictionary Source="DataTemplates.xaml"/>
    </ResourceDictionary.MergedDictionaries>
</ResourceDictionary>
```

### 示例 2：按控件类型分离文件

```
Themes/
├── Generic.xaml              # 主入口文件
├── LeftPanel/
│   ├── LeftPanelStyle.xaml
│   ├── LeftPanelTemplate.xaml
│   └── LeftPanelBehavior.xaml
├── RightPanel/
│   ├── RightPanelStyle.xaml
│   ├── RightPanelTemplate.xaml
│   └── RightPanelBehavior.xaml
└── SegmentControl/
    ├── SegmentControlStyle.xaml
    ├── SegmentControlTemplate.xaml
    └── SegmentControlBehavior.xaml
```

```xml
<!-- Generic.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <ResourceDictionary.MergedDictionaries>
        <!-- LeftPanel -->
        <ResourceDictionary Source="LeftPanel/LeftPanelStyle.xaml"/>
        <ResourceDictionary Source="LeftPanel/LeftPanelTemplate.xaml"/>
        <ResourceDictionary Source="LeftPanel/LeftPanelBehavior.xaml"/>

        <!-- RightPanel -->
        <ResourceDictionary Source="RightPanel/RightPanelStyle.xaml"/>
        <ResourceDictionary Source="RightPanel/RightPanelTemplate.xaml"/>
        <ResourceDictionary Source="RightPanel/RightPanelBehavior.xaml"/>

        <!-- SegmentControl -->
        <ResourceDictionary Source="SegmentControl/SegmentControlStyle.xaml"/>
        <ResourceDictionary Source="SegmentControl/SegmentControlTemplate.xaml"/>
        <ResourceDictionary Source="SegmentControl/SegmentControlBehavior.xaml"/>
    </ResourceDictionary.MergedDictionaries>
</ResourceDictionary>
```

### 示例 3：动态切换主题

```xml
<!-- LightTheme.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <SolidColorBrush x:Key="PrimaryBrush" Color="#0078D4"/>
    <SolidColorBrush x:Key="SecondaryBrush" Color="#CCCCCC"/>
    <SolidColorBrush x:Key="BackgroundBrush" Color="#FFFFFF"/>
</ResourceDictionary>
```

```xml
<!-- DarkTheme.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">

    <SolidColorBrush x:Key="PrimaryBrush" Color="#4CC2FF"/>
    <SolidColorBrush x:Key="SecondaryBrush" Color="#404040"/>
    <SolidColorBrush x:Key="BackgroundBrush" Color="#1E1E1E"/>
</ResourceDictionary>
```

```csharp
// 动态切换主题
public void ApplyTheme(string themeName)
{
    var themeUri = new Uri($"/TimeLine;component/Themes/{themeName}.xaml", UriKind.Relative);
    var themeResource = new ResourceDictionary { Source = themeUri };

    Application.Current.Resources.MergedDictionaries.Clear();
    Application.Current.Resources.MergedDictionaries.Add(themeResource);
    Application.Current.Resources.MergedDictionaries.Add(
        new ResourceDictionary { Source = new Uri("/TimeLine;component/Themes/Generic.xaml", UriKind.Relative) }
    );
}
```

## 注意事项

### 1. **避免样式冲突**

```xml
<!-- ❌ 不推荐：多个文件定义同一控件的完整样式 -->
<!-- 文件 1 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Background" Value="#F0F0F0"/>
    <Setter Property="Template">...</Setter>
</Style>

<!-- 文件 2 -->
<Style TargetType="local:SegmentControl">
    <Setter Property="Background" Value="#FFFFFF"/>  <!-- 冲突 -->
    <Setter Property="Template">...</Setter>        <!-- 冲突 -->
</Style>

<!-- ✅ 推荐：使用 BasedOn 继承 -->
<!-- 文件 1 -->
<Style x:Key="BaseSegmentStyle" TargetType="local:SegmentControl">
    <Setter Property="Background" Value="#F0F0F0"/>
</Style>

<!-- 文件 2 -->
<Style TargetType="local:SegmentControl" BasedOn="{StaticResource BaseSegmentStyle}">
    <Setter Property="Template">...</Setter>
</Style>
```

### 2. **资源键命名规范**

```xml
<!-- ✅ 推荐：使用有意义的命名 -->
<Style x:Key="SegmentControl.BaseStyle" TargetType="local:SegmentControl"/>
<Style x:Key="SegmentControl.HoverStyle" TargetType="local:SegmentControl"/>
<Style x:Key="SegmentControl.SelectedStyle" TargetType="local:SegmentControl"/>

<!-- ❌ 不推荐：使用通用命名 -->
<Style x:Key="Style1" TargetType="local:SegmentControl"/>
<Style x:Key="Style2" TargetType="local:SegmentControl"/>
```

### 3. **加载顺序很重要**

```xml
<!-- ✅ 推荐：明确指定加载顺序 -->
<ResourceDictionary.MergedDictionaries>
    <ResourceDictionary Source="Colors.xaml"/>           <!-- 1. 颜色 -->
    <ResourceDictionary Source="Brushes.xaml"/>          <!-- 2. 画刷 -->
    <ResourceDictionary Source="Converters.xaml"/>       <!-- 3. 转换器 -->
    <ResourceDictionary Source="BaseStyles.xaml"/>       <!-- 4. 基础样式 -->
    <ResourceDictionary Source="ControlStyles.xaml"/>      <!-- 5. 控件样式 -->
    <ResourceDictionary Source="ControlTemplates.xaml"/>  <!-- 6. 控件模板 -->
</ResourceDictionary.MergedDictionaries>
```

## 总结

### 核心答案

**是的，可以定义多个 ResourceDictionary 文件，同时指定一个控件的行为。**

### 实现方式

1. ✅ **合并多个 ResourceDictionary**：使用 `MergedDictionaries`
2. ✅ **在不同文件中定义同一控件的样式**：WPF 会自动合并
3. ✅ **使用 BasedOn 继承样式**：避免冲突，提高可维护性
4. ✅ **按功能模块分离文件**：提高代码组织性
5. ✅ **动态切换主题**：支持多主题

### 合并规则

1. **属性合并**：不同属性会合并
2. **属性覆盖**：相同属性，后加载的覆盖先加载的
3. **模板覆盖**：Template 会完全覆盖，不会合并

### 最佳实践

1. 使用 `BasedOn` 继承样式，避免冲突
2. 使用有意义的资源键命名
3. 明确指定加载顺序
4. 按功能模块或控件类型分离文件
5. 避免在多个文件中定义同一控件的完整样式
